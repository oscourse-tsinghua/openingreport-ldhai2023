# 精简内核
ReL4将同步ipc从内核态移除，内核仅支持异步通知机制，遵循内核最小化原则
![[Pasted image 20250117103347.png]]
- Endpoint
- notification
在用户态将共享内存作为ipc的数据通道，通知机制提供同步能力。

这种设计在传统微内核里可能有两个挑战:
- 性能问题，用户态通过通知机制进行同步，可能会造成大量的特权级切换，但是在我们的硬件上不存在。
- 用户态设计会变得更复杂，这原本就是一个trade off的问题，内核精简了，用户态就复杂了。

关于sel4中同步ipc主要有三个用途:
- 用户态数据通信
	- 异步IPC完全代替
- 内核态错误处理（如PageFault）
	- 内核态错误可以通过发送U-notification信号通知handler线程。
	- 错误信息的存储，由专门的与内核共享的内存存储（可以与异步系统调用共用同一个Buffer）。
	- handler中由recv协程唤醒之后读取错误信息并处理。
- 能力传递
	- 不支持IPC能力传递，由其他能力派生机制和系统调用代劳（损失兼容性）。
# 论文层次

- 系统需要支持的通知机制
	- 用户态通知用户态（U-notification）
		- 异步IPC的同步手段
	- 用户态通知内核态（系统调用）
		- 异步系统调用中唤醒内核的手段。
	- 内核态通知用户态（U-notification）
		- 异步系统调用中唤醒用户态的手段。
		- 错误处理中唤醒用户态的手段。

# 异步系统调用顺序性讨论

由于存在异步系统调用，可能会存在异步系统调用乱序执行的情况：
- 相同协程内的系统调用串行执行。
- 相同进程、不同协程的系统调用：
	- 对应同一个内核协程，执行顺序由用户态协程的提交顺序决定。
- 不同进程、不同协程的系统调用：
	- 对应了不同的内核协程。
	- 执行顺序由内核协程的调度顺序决定。
对于一个异步系统调用删除另一个异步系统调用正要操作的资源，由于最终的操作是由内核进行，而内核是独占的，因此系统调用总是能够按照确定的顺序执行，不存在并行导致的不安全和未定义行为。