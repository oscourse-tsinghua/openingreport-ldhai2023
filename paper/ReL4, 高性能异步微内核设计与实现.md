
# 摘要

以seL4为代表的现代微内核操作系统将同步IPC作为进程间通信的主要方式，同时借助需要内核转发的通知机制来实现用户态的中断处理和异步通信。然而随着微内核生态的发展，大量和频繁的系统调用和IPC的应用越来越需要微内核的支持，然而同步系统调用和IPC导致了大量的上下文切换和二级缓存失效，同时由于阻塞等待导致系统无法充分利用多核的性能；虽然微内核对异步信号有一定的支持，但都需要内核进行转发，其中的上下文切换和缓存失效在某些平台和场景下将造成不可忽视的开销。

本文聚焦微内核的异步通信机制，基于用户态中断技术，通过兼容capability机制和异步通信接口来改造seL4的通知机制，使得信号无需通过内核转发，减少上下切换的开销。同时利用无需内核转发的通知机制，借助共享内存和Rust对异步编程的支持设计和实现无需陷入内核的异步系统调用和异步IPC框架，在提升用户态并发度的同时，减少用户态和内核态的切换次数，在FPGA上将IPC性能最高提升了387.8%，在IPC频繁的系统中（如网络服务器）将吞吐量最高提升了15%。

关键词：微内核；异步；用户态中断。

# 1. 引言

- 微内核将大部分系统功能转移到用户态，应用程序请求一些公共服务通过IPC的形式来进行。而现代微内核大多以同步IPC作为进程间的通信方式，同时用异步的通知机制作为辅助。
- 然而无论是同步IPC还是异步通知机制都需要内核的参与转发，对于需要进行大量IPC请求的系统而言，用户态-内核-用户态的上下文切换将成为系统的性能瓶颈。
- 本文利用用户态中断来改造异步通知机制，使得异步通知无需通过内核转发，避免了特权级的切换和缓存失效。同时在此基础上设计和实现了一套完全异步的IPC和系统调用框架，大幅度减少了特权级的切换次数，提升系统的整体性能。
- 后续将从背景与动机、系统设计、实现细节、性能评估四个方面介绍我们的工作。

微内核从被提出以来，最大的性能瓶颈就是IPC（进程间通信），30年前Liedtke提出的L4通过对内核系统的重新设计，证明了微内核的IPC也可以很快，之后以seL4为代表的微内核的IPC框架也基本延续了最初的L4，以同步IPC作为主要的通信方式，同时引入异步的通知机制来简化多线程程序设计，并提升多核的利用率。然而随着软件性能要求不断提升，seL4中的IPC通信方式并不能很好的满足。首先是软件对系统有了新的要求，随着软件复杂性的提升，系统级软件如数据库管理系统、网络服务器等，需要进行大量的系统调用和IPC，这要求系统能够以快速高效的形式处理大量系统调用和IPC，而微内核将操作系统的大部分服务（如网络协议栈、文件系统等）移到用户态，从而使得IPC数量和频率激增，内核态与用户态之间的上下文切换成为性能瓶颈。此外，新出现的硬件漏洞如Meltdown 和 Spectre漏洞促使 Linux 使用 KPTI 补丁来分离用户程序和内核的页表，进一步增加了陷入内核的开销，seL4 中也有类似的机制。最后，外设速度越来越快，而现代微内核的外设驱动往往存在于用户态，外设中断被转化为通知信号，需要用户态驱动主动陷入内核来进行接收，这在很大程度上成为了外设驱动的性能瓶颈。

综上所述，以seL4为代表的现代微内核在IPC和系统调用架构的设计上仍然有很大的上下文切换开销，主要体现在以下两个方面：1）系统调用和同步IPC需要频繁的出入内核。2）通知机制需要内核转发。大量而频繁的特权级切换成为了系统的性能瓶颈。

我们的方法：在这篇文章中，我们提出了ReL4，一个用Rust编写的基于用户态中断的高性能异步微内核，它利用用户态中断技术在兼容capability的基础上改造微内核的通知机制，并利用改造后的通知机制和共享内存设计和实现了一个一套绕过内核的异步IPC框架。从广义的角度来看，系统调用作为一种特殊的IPC形式，我们同样借助IPC框架对系统调用进行异步化改造，从而设计和实现了一个完全异步的微内核架构。

这里有一些挑战需要被注意到：
- 用户态中断虽然与通知机制的作用相符合，但对于通信权限的控制是否足够

本文将从背景与动机、系统设计、实现细节、性能评估四个方面介绍我们的工作。

现代微内核的大部分IPC优化始于Liedtke提出的L4，L4通过组合系统调用的方式减少不必要的内核陷入开销，通过消息寄存器避免内存拷贝，通过同步IPC减少等待时间和上下文切换的开销，通过快速路径的方式减少IPC内核路径。

同步IPC虽然在抽象上是最小化的，并且在L4的设计与实现上都很简单，但后续的实践证明了同步IPC强制用户对原本简单的系统进行多线程设计，导致线程同步变得复杂，例如：由于缺乏类似于Unix中select功能，每个中断源都需要一个单独的线程。此外，同步IPC强制非依赖关系的IPC调用以顺序的形式进行，无法充分利用硬件的并行性。

L4-embedded通过在内核中新增非阻塞的通知机制来解决这个问题，其在seL4中被完善为一组二进制信号量的数组，通知对象通过非阻塞操作来发送信号，而接收方可以通过轮询或阻塞等待信号来检查通知字。此外，内核通过该方式将硬件中断传递到用户态，从而方便了用户态驱动的框架的设计与实现。尽管严格来说通知机制不是最小化的（因为它可以通过同步IPC机制模拟实现），但它对于减少用户态开发复杂性、充分利用硬件并发性起着至关重要的作用。

此外，随着访存速度的加快，L4中通过物理的消息寄存器进行零拷贝优化的方案带来的收益逐渐削弱，相反使用物理寄存器导致的平台依赖和编译器优化失效问题极大地限制了系统的性能，因此纷纷被现代微内核以虚拟消息寄存器的方式所替代[3]。

原始L4微内核使用临时内存映射的方式避免长消息的内存拷贝，但由于在内核中引入了缺页异常的可能性，增加了内核行为的复杂性，现代微内核纷纷放弃了长消息的传递，一般通过通知机制和共享内存组合的方式来进行长消息的传递[3]。

上述的研究和优化方案大都聚焦于IPC的内核路径优化，通过减少IPC路径的解码和调度，减少内存拷贝等方式来减少IPC的性能开销，也已经取得了很大的成果，事实上，在其最简单的情况下，同步IPC仅仅是一个上下文的切换，甚至不会改变消息寄存器。然而，随着内核路径开销越来越少，上下文切换的开销变得无法忽略，特别是对于有频繁的短消息传递和频繁的系统调用的应用，用户态-内核态的上下文切换开销已经成为限制系统性能的最大瓶颈。

现代微内核在软件上通过消息寄存器的方式减少上下文切换的大小，从而在一定程度上减少了上下文切换的开销；通过组合Send & Recv系统调用（以及Recv & Reply）减少陷入内核的次数；在硬件上通过利用ASID减少块表的冲刷频率，从而减小页表的切换开销，这些方法虽然都在一定程度上减少了上下文切换的开销，但无法彻底消除。

在微内核外，还有一些工作致力于减少系统调用中的切换开销，主要分为两类。

第一类方法通过将用户态和内核态的功能扁平化来减少内核与用户态的切换开销，如unikerel将所有用户态代码都映射到内核态执行，Userspace Bypass通过动态二进制分析将两个系统调用之间的用户态代码移入内核态执行，从而减少陷入内核的次数，kernel bypass则通过将硬件驱动（传统内核的功能）移入用户态，从而减少上下文的切换。这些方法要么需要特殊的硬件支持，要么难以与微内核的设计理念兼容，因此都只能提供一定的参考价值。

第二类方法则是允许用户空间对多个系统调用请求排队，并仅通过一个系统调用来将他们注册给内核。如FlexSC通过在用户态设计一个用户态线程的运行时，将用户态线程发起的系统调用自动收集，然后陷入内核态进行批量执行。该方法虽然可以有效的减少陷入内核的次数，却需要在内核态引入复杂的异步运行时，这与微内核的最小化原则相悖。

综上所述，上述方法要么无法彻底消除上下文切换的性能瓶颈，要么无法有效地实施到微内核中。随着硬件的不断发展，用户态中断——一种新兴的硬件技术方案逐渐被各个硬件平台（x86、RISC-V）采纳并很好地解决了上述提到的问题。用户态中断通过硬件的方式，在无需陷入内核的情况下，将信号发送给其他用户态程序。该机制仅需在通信注册过程中陷入内核，以分配用于通信的相关硬件资源，后续的通信过程无需内核接入，很好地避免了用户态和内核态的上下文切换。目前已经在Sapphire Rapids x86处理器上和RISCV的N扩展中有支持。


# 2. 背景与设计目标

## 2.1 介绍背景
- 介绍微内核的发展，以及改进IPC性能在微内核中的已有方法，从而导出现代微内核中IPC的两个问题：
	- 同步IPC对多核利用效率不高。
	- 性能瓶颈：特权级切换。
- 介绍特权级切换产生的开销：
	- 上下文切换。
	- 页表切换。
	- 缓存失效，快表污染。
- 介绍减少特权级切换的相关工作，以及相关的优缺点：
	- 通过将用户态和内核态的功能扁平化来减少内核与用户态的切换开销，eg: unikernel、UB等。
	- 允许用户空间对多个系统调用请求排队，批量系统调用的方式均摊上下文切换的成本，如FlexSC等。
## 2.2 设计目标
- 希望利用用户态中断减少特权级的切换次数，提升系统性能。
- 希望兼容原始的notification借口，保证兼容性。
- 希望利用Rust语言协程机制自动收集IPC请求和系统调用请求，提升易用性。

# 3. 设计

## 3.1 基于用户态中断的微内核异步通知机制
- 通信权限控制
	- 注册流程。
- 兼容性设计
	- 注册兼容。
	- 通信方式兼容。
## 3.2 异步IPC
- 框架设计
- 用户态异步运行时
- IPCBuffer结构设计
## 3.3 异步系统调用
- 内核异步运行时
- CPU资源分配
# 4. 实现
- 新增系统调用
- 无锁的环形缓冲区。
- 自适应的混合轮询。
- 优先级机制。

# 5. 性能评估
- micro-benchmark：与同步IPC的平均开销进行对比
	- 实验设置。
	- 性能分析。
	- 结论。
-  macro-benchmark: 
	- 基于axi-net网卡驱动和smoltcp来实现用户态网络协议栈，同步调用和异步调用进行对比。
	- 物理内存分配器的性能测试（用于测试异步系统调用的性能）。
		- 实验设置。
		- 性能分析。
		- 结论。
# 6. 总结
- 总结研究内容，强调研究结果：本文利用用户态中断机制在微内核中设计了一套无需陷入内核的异步IPC框架，并基于异步IPC框架对系统调用也进行了异步化改造，从而设计出一个完全异步的高性能微内核，经测试，异步IPC将IPC的性能最高提升了387.8%，在IPC频繁的系统中（如网络服务器）将系统性能最高提升15%。
- 论述研究意义，提升论文定位：异步IPC和异步系统调用主要是为了提升高频度、上下文无关的IPC和系统调用请求的整体处理性能，因此在并发度高的系统中拥有卓越的表现，此外，在并发度低的情况下，我们仍然通过用户态中断这种开销相对较小的方式来取代特权级切换，从而在一定程度上弥补了低并发度情况下引入异步运行时带来的额外开销。
- 展望后续研究，进行简单介绍：我们期望用硬件实现异步运行时中的频繁操作（如fetch、wake等），从而尽可能消除运行时对性能的影响，在低并发度的情况下也能取得良好的性能。