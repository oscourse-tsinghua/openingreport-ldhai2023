
# 摘要

以seL4为代表的现代微内核操作系统将同步IPC作为进程间通信的主要方式，同时借助需要内核转发的通知机制来实现用户态的中断处理和异步通信。然而随着微内核生态的发展，大量和频繁的系统调用和IPC的应用越来越需要微内核的支持，然而同步系统调用和IPC导致了大量的上下文切换和二级缓存失效，同时由于阻塞等待导致系统无法充分利用多核的性能；虽然微内核对异步信号有一定的支持，但都需要内核进行转发，其中的上下文切换和缓存失效在某些平台和场景下将造成不可忽视的开销。

本文聚焦微内核的异步通信机制，基于用户态中断技术，通过兼容capability机制和异步通信接口来改造seL4的通知机制，使得信号无需通过内核转发，减少上下切换的开销。同时利用无需内核转发的通知机制，借助共享内存和Rust对异步编程的支持设计和实现无需陷入内核的异步系统调用和异步IPC框架，在提升用户态并发度的同时，减少用户态和内核态的切换次数，在FPGA上将IPC性能最高提升了387.8%，在IPC频繁的系统中（如网络服务器）将吞吐量最高提升了15%。

关键词：微内核；异步；用户态中断。

# 1. 引言


微内核从被提出以来，最大的性能瓶颈就是IPC（进程间通信），30年前Liedtke提出的L4通过对内核系统的重新设计，证明了微内核的IPC也可以很快，之后以seL4为代表的微内核的IPC框架也基本延续了最初的L4，以同步IPC作为主要的通信方式，同时引入异步的通知机制来简化多线程程序设计，并提升多核的利用率。然而随着软件性能要求不断提升，seL4中的IPC通信方式并不能很好的满足。首先是软件对系统有了新的要求，随着软件复杂性的提升，系统级软件如数据库管理系统、网络服务器等，需要进行大量的系统调用和IPC，这要求系统能够以快速高效的形式处理大量系统调用和IPC，而微内核将操作系统的大部分服务（如网络协议栈、文件系统等）移到用户态，从而使得IPC数量和频率激增，内核态与用户态之间的上下文切换成为性能瓶颈。此外，新出现的硬件漏洞如Meltdown 和 Spectre漏洞促使 Linux 使用 KPTI 补丁来分离用户程序和内核的页表，进一步增加了陷入内核的开销，seL4 中也有类似的机制。最后，外设速度越来越快，而现代微内核的外设驱动往往存在于用户态，外设中断被转化为通知信号，需要用户态驱动主动陷入内核来进行接收，这在很大程度上成为了外设驱动的性能瓶颈。

综上所述，以seL4为代表的现代微内核在IPC和系统调用架构的设计上仍然有很大的上下文切换开销，主要体现在以下两个方面：1）系统调用和同步IPC需要频繁的出入内核。2）通知机制需要内核转发。大量而频繁的特权级切换成为了系统的性能瓶颈。

我们的方法：在这篇文章中，我们提出了ReL4，一个用Rust编写的基于用户态中断的高性能异步微内核，它利用用户态中断技术在兼容capability的基础上改造微内核的通知机制，并利用改造后的通知机制和共享内存设计和实现了一个一套绕过内核的异步IPC框架。从广义的角度来看，系统调用作为一种特殊的IPC形式，我们同样借助IPC框架对系统调用进行异步化改造，从而设计和实现了一个完全异步的微内核架构。

这里有一些挑战需要被注意到：
- 用户态中断虽然与通知机制的作用相似，但对于通信权限的控制如何与capability机制兼容，以及中断的抢占式行为与notification的主动询问的用法如何进行兼容，仍然需要我们进行仔细的设计。
- 用户态中断的开销小于特权级切换，但仍然对程序局部性和内存缓存不够友好，因此我们需要尽可能减少用户态中断的次数。
- 由于内核往往与用户态程序共用CPU核心，因此对于异步系统调用，在不破坏微内核已有的任务特权级机制前提下，内核如何快速高效地执行异步系统调用请求，从而尽可能地利用CPU资源值得我们深入思考。

为了评估我们的设计与实现，我们在ReL4评估了不同负载下单次IPC的平均开销，同时在ReL4上搭建了一个TCP服务器和一个用户内存分配用于评估整体的系统性能。经测试，我们在FPGA上将IPC性能最高提升了387.8%，在IPC频繁的系统中（如网络服务器）将吞吐量最高提升了15%。

本文将从背景与动机、系统设计、实现细节、性能评估四个方面介绍我们的工作。


# 2. 背景与设计目标

## 2.1 介绍背景
- 介绍微内核的发展，以及改进IPC性能在微内核中的已有方法，从而导出现代微内核中IPC的两个问题：
	- 同步IPC对多核利用效率不高。
	- 性能瓶颈：特权级切换。
- 介绍特权级切换产生的开销：
	- 上下文切换。
	- 页表切换。
	- 缓存失效，快表污染。
- 介绍减少特权级切换的相关工作，以及相关的优缺点：
	- 通过将用户态和内核态的功能扁平化来减少内核与用户态的切换开销，eg: unikernel、UB等。
	- 允许用户空间对多个系统调用请求排队，批量系统调用的方式均摊上下文切换的成本，如FlexSC等。
## 2.2 设计目标
- 希望利用用户态中断减少特权级的切换次数，提升系统性能。
- 希望兼容原始的notification借口，保证兼容性。
- 希望利用Rust语言协程机制自动收集IPC请求和系统调用请求，提升易用性。

# 3. 设计

## 3.1 基于用户态中断的微内核异步通知机制
- 通信权限控制
	- 注册流程。
- 兼容性设计
	- 注册兼容。
	- 通信方式兼容。
## 3.2 异步IPC
- 框架设计
- 用户态异步运行时
- IPCBuffer结构设计
## 3.3 异步系统调用
- 内核异步运行时
- CPU资源分配
# 4. 实现
- 新增系统调用
- 无锁的环形缓冲区。
- 自适应的混合轮询。
- 优先级机制。

# 5. 性能评估
- micro-benchmark：与同步IPC的平均开销进行对比
	- 实验设置。
	- 性能分析。
	- 结论。
-  macro-benchmark: 
	- 基于axi-net网卡驱动和smoltcp来实现用户态网络协议栈，同步调用和异步调用进行对比。
	- 物理内存分配器的性能测试（用于测试异步系统调用的性能）。
		- 实验设置。
		- 性能分析。
		- 结论。
# 6. 总结
- 总结研究内容，强调研究结果：本文利用用户态中断机制在微内核中设计了一套无需陷入内核的异步IPC框架，并基于异步IPC框架对系统调用也进行了异步化改造，从而设计出一个完全异步的高性能微内核，经测试，异步IPC将IPC的性能最高提升了387.8%，在IPC频繁的系统中（如网络服务器）将系统性能最高提升15%。
- 论述研究意义，提升论文定位：异步IPC和异步系统调用主要是为了提升高频度、上下文无关的IPC和系统调用请求的整体处理性能，因此在并发度高的系统中拥有卓越的表现，此外，在并发度低的情况下，我们仍然通过用户态中断这种开销相对较小的方式来取代特权级切换，从而在一定程度上弥补了低并发度情况下引入异步运行时带来的额外开销。
- 展望后续研究，进行简单介绍：我们期望用硬件实现异步运行时中的频繁操作（如fetch、wake等），从而尽可能消除运行时对性能的影响，在低并发度的情况下也能取得良好的性能。