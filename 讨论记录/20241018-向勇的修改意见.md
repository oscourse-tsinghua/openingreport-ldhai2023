1. 文字的流畅性问题；
2. 参考文献的标注问题：文献还没有加引用出处；
3. 异步系统调用和异步IPC的两张图需要明显地区分出它们的相同点和不同点；
4. UINTC在全文中出现了两次。建议补充对UINTC的描述。
5. 3.1节的图中接收线程的控制流箭头方向反了。是这样吗？
6. 如何理解“发送方通过能力派生的形式获取指向Notification对象的Capability”？
7. 3.1节中两种通知机制的描述是混在一起的。建议先说基于用户态中断的通知机制，再说与原来的异同，最后说如何兼容。
8. 3.2.2节中的调度器需要单独的描述，以明确你的调度器是通过vDSO在内核与应用进程间共享的，具备按统一优先级进行调度的能力。
9. 我认为，异步运行时的讨论中用call和recv_reply作为例子有些复杂了，就以IPC的收方注册、发方注册、发送和接收作为例子，好像好像会更简洁一些。你如何看？
10. 3.2.3节关于优先级的讨论中，没有表达出统一调度的特征来。目前的描述只是说了你想要达到的效果，并没有说清楚如何实现“优先级调度”。
11. 3.3节图中内核的调度器与异步运行时中的调度器是什么关系？现在的做法（描述）直接导致了执行优先级和协程优先级的区别，很难说清楚。我认为它们应该就是一个东西。对吗？
12. “对于第一点，我们只需要新增一个系统调用去用于唤醒相关的内核协程即可。”，这是为什么？我认为，原本的ecall就可以通知内核的。成立吗？4.1节中的UintrWakeSyscallHandler也与此相关，需要一直考虑。
13. 3.3节中关于内核抢占的描述有问题。前面说内核是互斥访问的，不能抢占；
14. “异步系统调用的处理可能是一个十分耗时的过程”。这是为什么？
15. 我认为4.1中UintrRegisterAsyncSyscall和UintrWakeSyscallHandler的设计不合理。异步系统调用的结果返回应该是用户态中断的响应future来完成，它的注册应该有应用进程开始执行时完成。当面交流吧。
16. 4.2节的描述还需要推敲。“请求频率足够高或服务端负载足够大”如何量化？
17. 实验结果的曲线图中，需要明确各坐标轴的含义和单位。
18. 5.1节中单核场景下的异步IPC，如果优先级设置适当，应该不会比同步IPC差太多。我的理解有问题吗？
19. 5.1节的实验场景需要有所描述。目前没有相关的段落。
20. 5.2节的实验结果中，低并发场景下的数据好像与5.1节的结果有些矛盾。你如何看？
21. 5.3节的实验结果没有看太明白。当面交流吧。
22. 结论中，“低并发度情况下引入异步运行时带来的额外开销”的支撑论述有些不明白。
