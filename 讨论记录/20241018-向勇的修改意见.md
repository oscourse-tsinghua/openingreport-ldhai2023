1. 文字的流畅性问题；
2. 参考文献的标注问题：文献还没有加引用出处；
	1. 已修改
3. 异步系统调用和异步IPC的两张图需要明显地区分出它们的相同点和不同点；
	1. 调度（recv）协程
	2. 两者的区别
4. UINTC在全文中出现了两次。建议补充对UINTC的描述。
	1. acc
5. 3.1节的图中接收线程的控制流箭头方向反了。是这样吗？
	1. 是的。
	2. 用三种颜色标注
6. 如何理解“发送方通过能力派生的形式获取指向Notification对象的Capability”？
	1. 通过cnode_copy等系统调用生成指向同一个内核对象的不同capability。
	2. 通过主进程创建的内核通道
7. 3.1节中两种通知机制的描述是混在一起的。建议先说基于用户态中断的通知机制，再说与原来的异同，最后说如何兼容。
	1. 与异步运行时的依赖，是否环形依赖。
		1. 只依赖调度器部分，调度器功能不依赖U-notificaiton。
8. 3.2.2节中的调度器需要单独的描述，以明确你的调度器是通过vDSO在内核与应用进程间共享的，具备按统一优先级进行调度的能力。
	1. 我的工作里没有使用vDSO
9. 我认为，异步运行时的讨论中用call和recv_reply作为例子有些复杂了，就以IPC的收方注册、发方注册、发送和接收作为例子，好像好像会更简洁一些。你如何看？
	1. 我认为call会更具有代表性，也是后续实验的主要场景。
10. 3.2.3节关于优先级的讨论中，没有表达出统一调度的特征来。目前的描述只是说了你想要达到的效果，并没有说清楚如何实现“优先级调度”。
	1. 这里优先级调度的实现是有说明的，但实现方式比较简单。
	2. 说明调度的范围。
11. 3.3节图中内核的调度器与异步运行时中的调度器是什么关系？现在的做法（描述）直接导致了执行优先级和协程优先级的区别，很难说清楚。我认为它们应该就是一个东西。对吗？
	1. 不是同一个东西。
12. “对于第一点，我们只需要新增一个系统调用去用于唤醒相关的内核协程即可。”，这是为什么？我认为，原本的ecall就可以通知内核的。成立吗？4.1节中的UintrWakeSyscallHandler也与此相关，需要一直考虑。
	1. 
13. 3.3节中关于内核抢占的描述有问题。前面说内核是互斥访问的，不能抢占；
	1. 这里的抢占不是指抢占内核，而是只将抢占正在执行低优先级的CPU（一般在执行用户态程序）。
14. “异步系统调用的处理可能是一个十分耗时的过程”。这是为什么？
	1. 因为可能会有很多个系统调用请求。
15. 我认为4.1中UintrRegisterAsyncSyscall和UintrWakeSyscallHandler的设计不合理。异步系统调用的结果返回应该是用户态中断的响应future来完成，它的注册应该有应用进程开始执行时完成。当面交流吧。
16. 4.2节的描述还需要推敲。“请求频率足够高或服务端负载足够大”如何量化？
	1. 当上一个请求没有处理完时。
17. 实验结果的曲线图中，需要明确各坐标轴的含义和单位。
	1. acc
18. 5.1节中单核场景下的异步IPC，如果优先级设置适当，应该不会比同步IPC差太多。我的理解有问题吗？
	1. 如果是没有并发的话，会有调度器的开销和用户态中断开销
	2. 原因分析
19. 5.1节的实验场景需要有所描述。目前没有相关的段落。
	1. 我的理解是乒乓测试的场景比较常见，我就一句话带过了。
	2. 场景有点复杂
20. 5.2节的实验结果中，低并发场景下的数据好像与5.1节的结果有些矛盾。你如何看？
	1. 这里我的理解是同步下有更多机会处于内核态，导致网卡中断无法被及时响应。
	2. 需要额外交代
21. 5.3节的实验结果没有看太明白。当面交流吧。
	1. 放到前面
22. 结论中，“低并发度情况下引入异步运行时带来的额外开销”的支撑论述有些不明白。
	1. 每个环节的开销分析。
